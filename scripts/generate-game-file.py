#!/usr/bin/env python3
"""
generate-game-file.py

Create or normalize a standardized CRC game file in _games/<game_id>.md

Usage examples:

1) Create from JSON file
   python scripts/generate-game-file.py create --input game.json --out _games/hades-2.md

2) Create from stdin
   cat game.json | python scripts/generate-game-file.py create --out _games/hades-2.md

3) Normalize an existing game file
   python scripts/generate-game-file.py normalize --infile _games/hades-2.md --out _games/hades-2.md
"""

from __future__ import annotations

import argparse
import json
import os
import re
from typing import Any, Dict, List, Optional, Tuple


# -----------------------------
# Helpers
# -----------------------------

def slugify(s: str) -> str:
  s = (s or "").strip().lower()
  s = re.sub(r"[â€™']", "", s)
  s = re.sub(r"[^a-z0-9]+", "-", s)
  s = re.sub(r"-{2,}", "-", s)
  s = s.strip("-")
  return s


def ensure_list(x: Any) -> List[Any]:
  if x is None:
    return []
  if isinstance(x, list):
    return x
  return [x]


def as_bool(x: Any, default: bool = False) -> bool:
  if isinstance(x, bool):
    return x
  if isinstance(x, str):
    v = x.strip().lower()
    if v in ("true", "yes", "1", "y", "on"):
      return True
    if v in ("false", "no", "0", "n", "off"):
      return False
  if isinstance(x, (int, float)):
    return bool(x)
  return default


def clean_str(x: Any) -> str:
  return str(x).strip() if x is not None else ""


def unique_keep_order(items: List[str]) -> List[str]:
  seen = set()
  out = []
  for it in items:
    it = clean_str(it)
    if not it:
      continue
    if it in seen:
      continue
    seen.add(it)
    out.append(it)
  return out


def normalize_id_label_list(items: Any, id_key: str = "id", label_key: str = "name") -> List[Dict[str, str]]:
  """
  Accepts:
    - ["hitless", "damageless"]
    - [{"id":"hitless","name":"Hitless"}]
    - [{"slug":"hitless","label":"Hitless"}]
  Produces:
    - [{"id":"hitless","name":"Hitless"}]
  """
  out: List[Dict[str, str]] = []
  for raw in ensure_list(items):
    if raw is None:
      continue

    if isinstance(raw, str):
      sid = slugify(raw)
      if not sid:
        continue
      out.append({"id": sid, "name": raw.strip()})
      continue

    if isinstance(raw, dict):
      rid = clean_str(raw.get(id_key) or raw.get("id") or raw.get("slug") or raw.get("challenge_id"))
      rname = clean_str(raw.get(label_key) or raw.get("name") or raw.get("label") or raw.get("title") or rid)
      rid = slugify(rid) if rid else slugify(rname)
      if not rid:
        continue
      out.append({"id": rid, "name": rname or rid})
      continue

  # dedupe by id
  seen = set()
  deduped: List[Dict[str, str]] = []
  for it in out:
    if it["id"] in seen:
      continue
    seen.add(it["id"])
    deduped.append(it)
  return deduped


def normalize_categories(items: Any) -> List[Dict[str, Any]]:
  """
  Category contract:
    - slug: "any"
      name: "Any%"
      children:
        - slug: "underworld-any"
          name: "Underworld Any%"
  """
  out: List[Dict[str, Any]] = []
  for raw in ensure_list(items):
    if raw is None:
      continue

    if isinstance(raw, str):
      sid = slugify(raw)
      if not sid:
        continue
      out.append({"slug": sid, "name": raw.strip()})
      continue

    if isinstance(raw, dict):
      slug = clean_str(raw.get("slug") or raw.get("id") or raw.get("category_slug") or raw.get("key"))
      name = clean_str(raw.get("name") or raw.get("title") or slug)
      slug = slugify(slug) if slug else slugify(name)

      cat: Dict[str, Any] = {"slug": slug, "name": name or slug}
      children = raw.get("children") or raw.get("subcategories") or raw.get("subs")
      if children:
        cat["children"] = normalize_categories(children)
      out.append(cat)

  # dedupe by slug
  seen = set()
  deduped: List[Dict[str, Any]] = []
  for it in out:
    if it["slug"] in seen:
      continue
    seen.add(it["slug"])
    deduped.append(it)
  return deduped


def split_front_matter(md: str) -> Tuple[Dict[str, Any], str]:
  """
  Minimal front matter parser:
  - expects file begins with --- front matter ---
  - reads YAML-ish keys, but we only need to preserve the body and re-emit normalized YAML

  This is intentionally limited: it is for your controlled repo content.
  """
  if not md.startswith("---"):
    return {}, md

  parts = md.split("\n")
  if len(parts) < 3:
    return {}, md

  # find second '---'
  end = None
  for i in range(1, len(parts)):
    if parts[i].strip() == "---":
      end = i
      break
  if end is None:
    return {}, md

  fm_lines = parts[1:end]
  body = "\n".join(parts[end + 1:]).lstrip("\n")

  # naive YAML to dict via json-ish approach is not safe
  # Instead: we parse only simple "key: value" scalars; lists/maps should be provided via normalize input
  # For normalize mode, we strongly recommend the input file was generated by this tool already.
  fm: Dict[str, Any] = {}
  key_re = re.compile(r"^([A-Za-z0-9_]+):\s*(.*)$")
  current_key: Optional[str] = None
  for line in fm_lines:
    if not line.strip():
      continue
    m = key_re.match(line)
    if m:
      current_key = m.group(1)
      val = m.group(2).strip()
      if val == "":
        fm[current_key] = []
      else:
        # strip quotes
        if (val.startswith('"') and val.endswith('"')) or (val.startswith("'") and val.endswith("'")):
          val = val[1:-1]
        fm[current_key] = val
      continue

    # extremely minimal handling for indented list items under current_key
    if current_key and line.startswith("  - "):
      if not isinstance(fm.get(current_key), list):
        fm[current_key] = []
      fm[current_key].append(line.replace("  - ", "", 1).strip())

  return fm, body


def yaml_quote(s: str) -> str:
  # quote if needed
  if s == "":
    return '""'
  if re.search(r"[:\[\]\{\},#&*!|>'\"%@`]", s) or s.strip() != s or "\n" in s:
    return json.dumps(s)  # safe double-quoted string
  return s


def emit_yaml_value(v: Any, indent: int = 0) -> List[str]:
  sp = "  " * indent

  if isinstance(v, bool):
    return [f"{sp}{'true' if v else 'false'}"]
  if v is None:
    return [f"{sp}"]
  if isinstance(v, (int, float)):
    return [f"{sp}{v}"]
  if isinstance(v, str):
    return [f"{sp}{yaml_quote(v)}"]
  if isinstance(v, list):
    if len(v) == 0:
      return [f"{sp}[]"]
    lines: List[str] = []
    for item in v:
      if isinstance(item, (str, int, float, bool)) or item is None:
        lines.append(f"{sp}- {emit_yaml_value(item, 0)[0].strip()}")
      elif isinstance(item, dict):
        lines.append(f"{sp}-")
        lines.extend(emit_yaml_dict(item, indent + 1))
      else:
        lines.append(f"{sp}- {yaml_quote(str(item))}")
    return lines
  if isinstance(v, dict):
    if len(v) == 0:
      return [f"{sp}{{}}"]
    lines: List[str] = []
    lines.extend(emit_yaml_dict(v, indent))
    return lines

  return [f"{sp}{yaml_quote(str(v))}"]


def emit_yaml_dict(d: Dict[str, Any], indent: int = 0) -> List[str]:
  sp = "  " * indent
  lines: List[str] = []
  for k, v in d.items():
    if isinstance(v, dict):
      lines.append(f"{sp}{k}:")
      lines.extend(emit_yaml_dict(v, indent + 1))
    elif isinstance(v, list):
      if len(v) == 0:
        lines.append(f"{sp}{k}: []")
      else:
        lines.append(f"{sp}{k}:")
        lines.extend(emit_yaml_value(v, indent))
    else:
      lines.append(f"{sp}{k}: {emit_yaml_value(v, 0)[0].strip()}")
  return lines


# -----------------------------
# Standardization contract
# -----------------------------

def standardize_game(data: Dict[str, Any]) -> Dict[str, Any]:
  title = clean_str(data.get("title") or data.get("name") or "")
  game_id = clean_str(data.get("game_id") or data.get("id") or slugify(title))
  game_id = slugify(game_id)

  # core fields
  out: Dict[str, Any] = {
    "layout": "game",
    "title": title or game_id,
    "game_id": game_id,
  }

  # optional cosmetics
  hero_image = clean_str(data.get("hero_image") or data.get("hero") or "")
  if hero_image:
    out["hero_image"] = hero_image

  aliases = ensure_list(data.get("aliases") or data.get("alias") or [])
  out["aliases"] = unique_keep_order([clean_str(a) for a in aliases])

  tags = ensure_list(data.get("tags") or [])
  out["tags"] = unique_keep_order([slugify(t) if isinstance(t, str) else clean_str(t) for t in tags])

  platforms = ensure_list(data.get("platforms") or [])
  out["platforms"] = unique_keep_order([clean_str(p) for p in platforms])

  # tabs (optional)
  tabs = data.get("tabs")
  if isinstance(tabs, list):
    out["tabs"] = tabs

  # categories
  out["categories"] = normalize_categories(data.get("categories") or [])

  # Standard vs Community challenges
  out["standard_challenges"] = normalize_id_label_list(data.get("standard_challenges") or data.get("challenges") or [])
  out["community_challenges"] = normalize_id_label_list(data.get("community_challenges") or data.get("community") or [])

  # character column + characters list
  cc = data.get("character_column") or {}
  cc_enabled = as_bool(cc.get("enabled"), default=False) if isinstance(cc, dict) else False
  cc_label = clean_str(cc.get("label")) if isinstance(cc, dict) else ""

  out["character_column"] = {
    "enabled": bool(cc_enabled),
    "label": cc_label or "Character"
  }

  # "characters" list can come from `characters_data` or `characters`
  out["characters"] = normalize_id_label_list(
    data.get("characters_data") or data.get("characters") or []
  )

  # glitches + restrictions
  out["glitches"] = normalize_id_label_list(data.get("glitches") or [])
  out["restrictions"] = normalize_id_label_list(data.get("restrictions") or [])

  # notes / description (optional)
  desc = clean_str(data.get("description") or "")
  if desc:
    out["description"] = desc

  return out


def build_md(front_matter: Dict[str, Any], body: str) -> str:
  lines = ["---"]
  lines.extend(emit_yaml_dict(front_matter, 0))
  lines.append("---")
  lines.append("")
  lines.append(body.rstrip() + ("\n" if body and not body.endswith("\n") else ""))
  return "\n".join(lines)


# -----------------------------
# CLI
# -----------------------------

def main() -> None:
  ap = argparse.ArgumentParser()
  sub = ap.add_subparsers(dest="cmd", required=True)

  ap_create = sub.add_parser("create", help="Create a standardized game file from JSON input")
  ap_create.add_argument("--input", help="Path to JSON input. If omitted, reads stdin.", default="")
  ap_create.add_argument("--out", help="Output path (e.g., _games/hades-2.md)", required=True)
  ap_create.add_argument("--body", help="Optional markdown body text", default="")

  ap_norm = sub.add_parser("normalize", help="Normalize an existing game file into the standard format")
  ap_norm.add_argument("--infile", help="Existing game file path", required=True)
  ap_norm.add_argument("--out", help="Output path (can be same as infile)", required=True)

  args = ap.parse_args()

  if args.cmd == "create":
    if args.input:
      with open(args.input, "r", encoding="utf-8") as f:
        data = json.load(f)
    else:
      raw = sys_stdin_read()
      data = json.loads(raw) if raw.strip() else {}

    fm = standardize_game(data)
    body = args.body or clean_str(data.get("body") or "")
    md = build_md(fm, body)

    os.makedirs(os.path.dirname(args.out) or ".", exist_ok=True)
    with open(args.out, "w", encoding="utf-8", newline="\n") as f:
      f.write(md)

    print(f"Wrote: {args.out}")
    return

  if args.cmd == "normalize":
    with open(args.infile, "r", encoding="utf-8") as f:
      md_in = f.read()

    fm_existing, body = split_front_matter(md_in)

    # If the existing file was made by this tool, fm_existing may be incomplete.
    # Prefer to keep body and rebuild front matter from any richer JSON block the repo might have elsewhere.
    # Here we standardize what we have.
    fm_std = standardize_game(fm_existing)

    md_out = build_md(fm_std, body)

    os.makedirs(os.path.dirname(args.out) or ".", exist_ok=True)
    with open(args.out, "w", encoding="utf-8", newline="\n") as f:
      f.write(md_out)

    print(f"Wrote: {args.out}")
    return


def sys_stdin_read() -> str:
  try:
    import sys
    return sys.stdin.read()
  except Exception:
    return ""


if __name__ == "__main__":
  main()
