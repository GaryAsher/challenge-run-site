name: Process Run Submission

# Triggered when:
# - A moderator adds a decision label (approved/rejected/needs-review)
# - A moderator comments with a command (/approve, /reject, /confirm, /cancel)

on:
  issues:
    types: [labeled]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # ============================================================
  # HANDLE LABEL-BASED DECISIONS
  # ============================================================
  handle-label:
    if: |
      github.event_name == 'issues' &&
      contains(github.event.issue.labels.*.name, 'run-submission') &&
      (
        github.event.label.name == 'approved' ||
        github.event.label.name == 'rejected' ||
        github.event.label.name == 'needs-community-review'
      )
    runs-on: ubuntu-latest
    steps:
      - name: Request Confirmation
        uses: actions/github-script@v7
        with:
          script: |
            const label = context.payload.label.name;
            const issue = context.payload.issue;
            
            let message = '';
            
            if (label === 'approved') {
              message = `## âš ï¸ Confirm Approval
              
            You are about to **approve** this run submission.

            This will:
            - Validate the video link
            - Create a run file in \`_queue_runs/\`
            - Create a runner profile if it doesn't exist
            - Open a PR for final validation
            
            **To confirm:** Comment \`/confirm\`
            **To cancel:** Comment \`/cancel\` or remove the \`approved\` label`;
            } else if (label === 'rejected') {
              message = `## âš ï¸ Confirm Rejection
            
            You are about to **reject** this run submission.
            
            This will:
            - Close this issue
            
            **To confirm with reason:** Comment \`/confirm [reason]\`
            **To cancel:** Comment \`/cancel\` or remove the \`rejected\` label
            
            Example: \`/confirm Video is private and cannot be verified\``;
            } else if (label === 'needs-community-review') {
              message = `## ðŸ” Flagged for Community Review
            
            This run has been flagged for additional review by the game's community moderators.
            
            **To confirm:** Comment \`/confirm\`
            **To cancel:** Comment \`/cancel\` or remove the label`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: message
            });
            
            // Add awaiting-confirmation label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: ['awaiting-confirmation']
            });

  # ============================================================
  # HANDLE COMMAND COMMENTS
  # ============================================================
  handle-command:
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.issue.labels.*.name, 'run-submission') &&
      (
        startsWith(github.event.comment.body, '/approve') ||
        startsWith(github.event.comment.body, '/reject') ||
        startsWith(github.event.comment.body, '/review') ||
        startsWith(github.event.comment.body, '/confirm') ||
        startsWith(github.event.comment.body, '/cancel')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Check Permissions
        id: check-perms
        uses: actions/github-script@v7
        with:
          script: |
            const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: context.payload.comment.user.login
            });
            
            const allowed = ['admin', 'write', 'maintain'].includes(permission.permission);
            
            if (!allowed) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: 'âŒ You do not have permission to use moderator commands.'
              });
            }
            
            core.setOutput('allowed', allowed);
            return allowed;

      - name: Parse Command
        if: steps.check-perms.outputs.allowed == 'true'
        id: parse-command
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body.trim();
            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name);
            
            // Parse command and argument
            const match = comment.match(/^\/(\w+)\s*(.*)?$/);
            if (!match) {
              core.setOutput('valid', false);
              return;
            }
            
            const command = match[1].toLowerCase();
            const argument = (match[2] || '').trim();
            
            // Determine action based on command and current state
            let action = '';
            let reason = '';
            
            if (command === 'approve') {
              action = 'add-approved-label';
            } else if (command === 'reject') {
              action = 'add-rejected-label';
              reason = argument;
            } else if (command === 'review') {
              action = 'add-review-label';
            } else if (command === 'confirm') {
              if (labels.includes('approved') && labels.includes('awaiting-confirmation')) {
                action = 'process-approval';
              } else if (labels.includes('rejected') && labels.includes('awaiting-confirmation')) {
                action = 'process-rejection';
                reason = argument;
              } else if (labels.includes('needs-community-review') && labels.includes('awaiting-confirmation')) {
                action = 'process-community-review';
              } else {
                action = 'nothing-to-confirm';
              }
            } else if (command === 'cancel') {
              action = 'cancel';
            }
            
            core.setOutput('valid', true);
            core.setOutput('command', command);
            core.setOutput('action', action);
            core.setOutput('reason', reason);
            
            console.log(`Command: ${command}, Action: ${action}, Reason: ${reason}`);

      - name: Add Approved Label
        if: steps.parse-command.outputs.action == 'add-approved-label'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['approved']
            });

      - name: Add Rejected Label
        if: steps.parse-command.outputs.action == 'add-rejected-label'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['rejected']
            });

      - name: Add Review Label
        if: steps.parse-command.outputs.action == 'add-review-label'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['needs-community-review']
            });

      - name: Cancel Action
        if: steps.parse-command.outputs.action == 'cancel'
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const labelsToRemove = ['approved', 'rejected', 'needs-community-review', 'awaiting-confirmation'];
            
            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: label
                });
              } catch (e) {}
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: 'âœ… Action cancelled. Issue returned to pending review.'
            });
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: ['pending-review']
            });

      - name: Nothing to Confirm
        if: steps.parse-command.outputs.action == 'nothing-to-confirm'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: 'â“ Nothing to confirm. Use `/approve`, `/reject [reason]`, or `/review` first.'
            });

      # ============================================================
      # PROCESS APPROVAL - STEP 1: VALIDATE VIDEO LINK
      # ============================================================
      - name: Validate Video Link
        if: steps.parse-command.outputs.action == 'process-approval'
        id: validate-video
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            // Extract video link from issue body
            const videoMatch = body.match(/### Video Link\s*\n\s*([^\n]+)/i) ||
                               body.match(/(https?:\/\/(?:www\.)?(?:youtube\.com|youtu\.be|twitch\.tv|clips\.twitch\.tv|bilibili\.com|b23\.tv)[^\s\n]+)/i);
            
            if (!videoMatch) {
              core.setOutput('valid', 'false');
              core.setOutput('error', 'Could not find video link in submission');
              return;
            }
            
            const videoUrl = videoMatch[1].trim();
            console.log(`Validating video URL: ${videoUrl}`);
            
            // Validation patterns
            const VALID_PATTERNS = {
              youtube: [
                /^https?:\/\/(www\.)?youtube\.com\/watch\?v=[\w-]+/i,
                /^https?:\/\/youtu\.be\/[\w-]+/i,
                /^https?:\/\/(www\.)?youtube\.com\/live\/[\w-]+/i,
              ],
              twitch_clip: [
                /^https?:\/\/clips\.twitch\.tv\/[\w-]+/i,
                /^https?:\/\/(www\.)?twitch\.tv\/\w+\/clip\/[\w-]+/i,
              ],
              twitch_video: [
                /^https?:\/\/(www\.)?twitch\.tv\/videos\/\d+/i,
              ],
              bilibili: [
                /^https?:\/\/(www\.)?bilibili\.com\/video\/[\w]+/i,
                /^https?:\/\/b23\.tv\/[\w]+/i,
              ],
            };
            
            // Rejected patterns - live streams
            const REJECTED_PATTERNS = [
              /^https?:\/\/(www\.)?twitch\.tv\/\w+\/?$/i,
            ];
            
            // Check rejected first
            for (const pattern of REJECTED_PATTERNS) {
              if (pattern.test(videoUrl)) {
                core.setOutput('valid', 'false');
                core.setOutput('error', `**Invalid video link:** Live streams are not accepted.\n\nPlease provide a recorded video:\n- YouTube\n- Twitch Highlight or Clip\n- Bilibili\n\nProvided: \`${videoUrl}\``);
                return;
              }
            }
            
            let source = null;
            let warning = '';
            
            // Check YouTube
            for (const pattern of VALID_PATTERNS.youtube) {
              if (pattern.test(videoUrl)) { source = 'youtube'; break; }
            }
            
            // Check Twitch clips
            if (!source) {
              for (const pattern of VALID_PATTERNS.twitch_clip) {
                if (pattern.test(videoUrl)) { source = 'twitch_clip'; break; }
              }
            }
            
            // Check Twitch videos (VOD or highlight - warn)
            if (!source) {
              for (const pattern of VALID_PATTERNS.twitch_video) {
                if (pattern.test(videoUrl)) {
                  source = 'twitch_video';
                  warning = 'âš ï¸ **Twitch VOD Warning**: Regular Twitch VODs expire after ~60 days. Please ensure this is a **Highlight** (permanent) rather than a regular VOD. If your video expires, your run record may be affected.';
                  break;
                }
              }
            }
            
            // Check Bilibili
            if (!source) {
              for (const pattern of VALID_PATTERNS.bilibili) {
                if (pattern.test(videoUrl)) { source = 'bilibili'; break; }
              }
            }
            
            if (!source) {
              core.setOutput('valid', 'false');
              core.setOutput('error', `**Invalid video link.** Accepted sources:\n- YouTube (youtube.com, youtu.be)\n- Twitch Highlights or Clips (clips.twitch.tv, twitch.tv/videos/)\n- Bilibili (bilibili.com, b23.tv)\n\nProvided: \`${videoUrl}\``);
              return;
            }
            
            core.setOutput('valid', 'true');
            core.setOutput('source', source);
            core.setOutput('warning', warning);
            core.setOutput('video_url', videoUrl);
            console.log(`Video validated: source=${source}`);

      - name: Reject Invalid Video
        if: steps.parse-command.outputs.action == 'process-approval' && steps.validate-video.outputs.valid == 'false'
        uses: actions/github-script@v7
        env:
          ERROR_MSG: ${{ steps.validate-video.outputs.error }}
        with:
          script: |
            const error = process.env.ERROR_MSG;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `## âŒ Video Link Validation Failed\n\n${error}\n\n---\nPlease update your submission with a valid video link. A moderator can then re-approve.`
            });
            
            // Remove labels
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              name: 'awaiting-confirmation'
            }).catch(() => {});
            
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              name: 'approved'
            }).catch(() => {});
            
            // Add needs-revision label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['needs-revision']
            });

      - name: Warn About Twitch VOD
        if: steps.parse-command.outputs.action == 'process-approval' && steps.validate-video.outputs.valid == 'true' && steps.validate-video.outputs.warning != ''
        uses: actions/github-script@v7
        env:
          WARNING_MSG: ${{ steps.validate-video.outputs.warning }}
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: process.env.WARNING_MSG
            });

      # ============================================================
      # PROCESS APPROVAL - STEP 2: CREATE RUN FILE
      # ============================================================
      - name: Checkout
        if: steps.parse-command.outputs.action == 'process-approval' && steps.validate-video.outputs.valid == 'true'
        uses: actions/checkout@v4

      - name: Setup Node.js
        if: steps.parse-command.outputs.action == 'process-approval' && steps.validate-video.outputs.valid == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Dependencies
        if: steps.parse-command.outputs.action == 'process-approval' && steps.validate-video.outputs.valid == 'true'
        run: npm ci

      - name: Create Run File
        if: steps.parse-command.outputs.action == 'process-approval' && steps.validate-video.outputs.valid == 'true'
        id: create-run
        uses: actions/github-script@v7
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const body = process.env.ISSUE_BODY;
            const issueNumber = process.env.ISSUE_NUMBER;
            
            // Parse GitHub Issue form fields
            function parseField(fieldLabel) {
              const regex = new RegExp(`### ${fieldLabel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\n\\n([^\\n]+)`, 'i');
              const match = body.match(regex);
              let value = match ? match[1].trim() : '';
              if (value === '_No response_' || value === 'None' || value === 'null') {
                value = '';
              }
              return value;
            }
            
            function parseTextarea(fieldLabel) {
              const regex = new RegExp(`### ${fieldLabel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\n\\n([\\s\\S]*?)(?=\\n###|$)`, 'i');
              const match = body.match(regex);
              let value = match ? match[1].trim() : '';
              if (value === '_No response_' || value === 'None') {
                value = '';
              }
              return value;
            }
            
            // Extract all fields - supports multiple form formats
            let gameId = parseField('Game');
            const gameOther = parseField('Game \\(if not listed\\)');
            if (gameId === 'OTHER (specify below)' && gameOther) {
              gameId = gameOther;
            }
            // Handle Hollow Knight specific form
            if (!gameId || gameId === '') {
              gameId = 'hollow-knight'; // Default for HK-specific form
            }
            
            const runner = parseField('Runner Name \\(Display\\)') || parseField('Runner Name');
            const runnerId = parseField('Runner ID');
            const contact = parseField('Contact \\(Optional\\)') || parseField('Discord / Contact \\(Optional\\)');
            
            let categorySlug = parseField('Category') || parseField('Category Slug');
            const categoryOther = parseField('Category \\(if OTHER\\)') || parseField('Category \\(if not listed\\)');
            if (categorySlug === 'OTHER (specify below)' && categoryOther) {
              categorySlug = categoryOther;
            }
            const categoryLabel = parseField('Category Display Name');
            
            let challengeId = parseField('Challenge Type');
            const challengeOther = parseField('Challenge Type \\(if OTHER\\)') || parseField('Challenge Type \\(if not listed\\)');
            if (challengeId === 'OTHER (specify below)' && challengeOther) {
              challengeId = challengeOther;
            }
            
            // Glitch category (optional)
            const glitchCategory = parseField('Glitch Category');
            
            const videoLink = parseField('Video Link');
            const dateCompleted = parseField('Date Completed');
            
            // Time fields - support both generic and HK-specific
            const timePrimary = parseField('Run Time') || parseField('Run Time \\(Optional\\)') || parseField('Time \\(LRT - Load Removed\\)');
            const timeRTA = parseField('Time \\(RTA - Real Time\\)');
            const timingMethod = parseField('Timing Method') || (timePrimary && timePrimary.includes('LRT') ? 'LRT' : '');
            
            // Platform and patch (HK specific)
            const platform = parseField('Platform');
            const patchVersion = parseField('Game Patch Version');
            
            const restrictions = parseTextarea('Restrictions / Modifiers \\(Optional\\)') || parseTextarea('Additional Restrictions \\(Optional\\)');
            const notes = parseTextarea('Additional Notes \\(Optional\\)') || parseTextarea('Additional Notes');
            
            // Validate required fields
            const missing = [];
            if (!gameId) missing.push('game_id');
            if (!runner) missing.push('runner');
            if (!runnerId) missing.push('runner_id');
            if (!categorySlug) missing.push('category_slug');
            if (!categoryLabel) missing.push('category');
            if (!challengeId) missing.push('challenge_id');
            if (!videoLink) missing.push('video_link');
            if (!dateCompleted) missing.push('date_completed');
            
            if (missing.length > 0) {
              core.setFailed(`Missing required fields: ${missing.join(', ')}`);
              return;
            }
            
            // Generate filename
            const today = new Date().toISOString().slice(0, 10);
            
            const queueDir = `_queue_runs/${gameId}`;
            let nn = 1;
            if (fs.existsSync(queueDir)) {
              const existing = fs.readdirSync(queueDir);
              const pattern = new RegExp(`^${today}__${gameId}__${runnerId}__[\\w-]+__(\\d+)\\.md$`);
              for (const file of existing) {
                const match = file.match(pattern);
                if (match) {
                  nn = Math.max(nn, parseInt(match[1], 10) + 1);
                }
              }
            }
            const nnStr = String(nn).padStart(2, '0');
            
            const categorySlugForFilename = categorySlug.replace(/\//g, '-');
            const filename = `${today}__${gameId}__${runnerId}__${categorySlugForFilename}__${nnStr}.md`;
            const filePath = `${queueDir}/${filename}`;
            
            // Build front matter
            let content = `---
            game_id: ${gameId}
            runner_id: ${runnerId}
            category_slug: ${categorySlug}
            challenge_id: ${challengeId}
            runner: "${runner}"
            category: "${categoryLabel}"
            date_submitted: ${today}
            date_completed: ${dateCompleted}
            video_link: ${videoLink}
            status: pending
            verified: false
            verified_by: ""`.replace(/^            /gm, '');
            
            if (glitchCategory && glitchCategory !== '""' && glitchCategory !== '') {
              content += `\nglitch_category: ${glitchCategory}`;
            }
            
            if (timePrimary) {
              content += `\ntime_primary: ${timePrimary}`;
              if (timingMethod && timingMethod !== '""' && timingMethod !== '') {
                content += `\ntiming_method_primary: ${timingMethod}`;
              }
            }
            
            if (timeRTA) {
              content += `\ntime_rta: ${timeRTA}`;
            }
            
            if (platform && platform !== '""' && platform !== '') {
              content += `\nplatform: "${platform}"`;
            }
            
            if (patchVersion && patchVersion !== '""' && patchVersion !== '') {
              content += `\npatch_version: "${patchVersion}"`;
            }
            
            if (restrictions) {
              const restrictionsList = restrictions.split('\n').filter(r => r.trim());
              if (restrictionsList.length > 0) {
                content += `\nrestrictions:`;
                for (const r of restrictionsList) {
                  content += `\n  - "${r.trim()}"`;
                }
              }
            }
            
            content += `\n---\n`;
            
            if (notes) {
              content += `\n${notes}\n`;
            }
            
            // Create directory and file
            fs.mkdirSync(queueDir, { recursive: true });
            fs.writeFileSync(filePath, content);
            
            console.log(`Created: ${filePath}`);
            
            // Check if runner exists, create if not
            const runnerFile = `_runners/${runnerId}.md`;
            let runnerCreated = false;
            
            if (!fs.existsSync(runnerFile)) {
              const runnerContent = `---
            layout: runner
            runner_id: ${runnerId}
            name: "${runner}"
            games:
              - ${gameId}
            ---
            `.replace(/^            /gm, '');
              
              fs.writeFileSync(runnerFile, runnerContent);
              runnerCreated = true;
              console.log(`Created runner: ${runnerFile}`);
            }
            
            // Set outputs
            core.setOutput('file_path', filePath);
            core.setOutput('filename', filename);
            core.setOutput('runner', runner);
            core.setOutput('runner_id', runnerId);
            core.setOutput('runner_created', runnerCreated);
            core.setOutput('game_id', gameId);
            core.setOutput('category', categoryLabel);

      - name: Create Pull Request
        if: steps.parse-command.outputs.action == 'process-approval' && steps.validate-video.outputs.valid == 'true'
        uses: peter-evans/create-pull-request@v5
        id: create-pr
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            Add run: ${{ steps.create-run.outputs.runner }} - ${{ steps.create-run.outputs.game_id }} ${{ steps.create-run.outputs.category }}
            
            Closes #${{ github.event.issue.number }}
          title: "[Run] ${{ steps.create-run.outputs.runner }} - ${{ steps.create-run.outputs.game_id }} ${{ steps.create-run.outputs.category }}"
          body: |
            ## Run Submission
            
            | Field | Value |
            |-------|-------|
            | **Runner** | ${{ steps.create-run.outputs.runner }} |
            | **Game** | ${{ steps.create-run.outputs.game_id }} |
            | **Category** | ${{ steps.create-run.outputs.category }} |
            | **File** | `${{ steps.create-run.outputs.file_path }}` |
            | **Runner Profile Created** | ${{ steps.create-run.outputs.runner_created }} |
            
            ---
            
            - [ ] Validation passes
            - [ ] Ready to merge
            
            Closes #${{ github.event.issue.number }}
          branch: "run/${{ github.event.issue.number }}"
          labels: |
            run-submission
            auto-generated

      - name: Comment Success
        if: steps.parse-command.outputs.action == 'process-approval' && steps.validate-video.outputs.valid == 'true'
        uses: actions/github-script@v7
        env:
          PR_URL: ${{ steps.create-pr.outputs.pull-request-url }}
        with:
          script: |
            const prUrl = process.env.PR_URL;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `## âœ… Run Approved!\n\nA pull request has been created: ${prUrl}\n\nThe PR will run validation checks automatically. Once checks pass, merge the PR to complete the submission.\n\nThis issue will be closed when the PR is merged.`
            });
            
            // Update labels
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              name: 'awaiting-confirmation'
            }).catch(() => {});
            
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              name: 'pending-review'
            }).catch(() => {});
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['pr-created']
            });

      # ============================================================
      # PROCESS REJECTION
      # ============================================================
      - name: Process Rejection
        if: steps.parse-command.outputs.action == 'process-rejection'
        uses: actions/github-script@v7
        env:
          REASON: ${{ steps.parse-command.outputs.reason }}
        with:
          script: |
            const reason = process.env.REASON || 'No reason provided';
            const issue = context.payload.issue;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## âŒ Run Rejected\n\n**Reason:** ${reason}\n\nIf you believe this was in error, please open a new submission with the issues addressed.`
            });
            
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              name: 'awaiting-confirmation'
            }).catch(() => {});
            
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              name: 'pending-review'
            }).catch(() => {});
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              state: 'closed',
              state_reason: 'not_planned'
            });

      # ============================================================
      # PROCESS COMMUNITY REVIEW
      # ============================================================
      - name: Process Community Review
        if: steps.parse-command.outputs.action == 'process-community-review'
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## ðŸ” Flagged for Community Review\n\nThis run has been flagged for additional review by community moderators.\n\nA community moderator will review this submission and make a final decision.\n\n**Community moderators:** Use \`/approve\` or \`/reject [reason]\` when review is complete.`
            });
            
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              name: 'awaiting-confirmation'
            }).catch(() => {});
            
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              name: 'pending-review'
            }).catch(() => {});
